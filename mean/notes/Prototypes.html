<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta
      name="viewport"
      content="width=
    , initial-scale=1.0"
    />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Document</title>
  </head>
  <body>
    <!-- Basics
    Prototype methods make our code faster. If we were creating thousands of instances, adding methods to the shared prototype will improve the performance of our code significantly! However, if you are only going to have a small amount of instances, you should balance prototype methods with readability. We only get performance gains from prototype methods when using a large number of instances.
    
    // Define the object constructor -->

    PROTOTYPES ARE METHODS THAT ARE GLOBALLY ACCESSIBLE
    <script>
      function Person(name, age) {
        this.name = name;
        this.age = age;
      }
      // Attach class methods using .prototype
      Person.prototype.greet = function() {
        console.log(
          "Hello my name is " +
            this.name +
            " and I am " +
            this.age +
            " years old!"
        );
        return this;
      };
      // Create new instances with the new keyword
      var amelia = new Person("Amelia", 36);
      // Create instance methods by attaching the function directly to an instance
      amelia.sing = function() {
        console.log("Lalalala!");
      };
    </script>

    ANOTHER BIG AHA MOFO MOMENT JavaScript v3 JS OOP ES5 OOPSearch zackary
    Hello, Zackary B Having issues? Report here. ES5 OOP Objectives: Review ES5
    object oriented programming. How to make private variables with ES5. How to
    chain methods. Here is a review of some of the important aspects of ES5 OOP
    in JavaScript. Make sure to read all the comments as you walk through the
    code. Basics Prototype methods make our code faster. If we were creating
    thousands of instances, adding methods to the shared prototype will improve
    the performance of our code significantly! However, if you are only going to
    have a small amount of instances, you should balance prototype methods with
    readability. We only get performance gains from prototype methods when using
    a large number of instances.
    <script>
      // Define the object constructor
      function Person(name, age) {
        this.name = name;
        this.age = age;
      }
      // Attach class methods using .prototype
      Person.prototype.greet = function() {
        console.log(
          "Hello my name is " +
            this.name +
            " and I am " +
            this.age +
            " years old!"
        );
        return this;
      };
      // Create new instances with the new keyword
      var amelia = new Person("Amelia", 36);
      // Create instance methods by attaching the function directly to an instance
      amelia.sing = function() {
        console.log("Lalalala!");
      };
    </script>
    SOFT PRIVACY AND METHOD CHAINING You may have seen other languages use
    public and private as keywords that change how accessible the data is.
    JavaScript does not have these keywords, but we can still make private
    variables and methods. In order to keep data private in a particular
    instance, we just need to leverage JavaScripts scoping rules. By creating
    variables scoped to the Object Constructor, we keep them out of the global
    scope. To read and update private data, we'll need to write getter and
    setter methods. Additionally, we can chain methods together by returning
    this. Essentially, whenever we tell a public or prototype method to return
    this, we're asking for the entire object back. This lets us chain function
    calls together. Ive seen .this used without the context of "new " in many
    other applications so its going to be hard to remember to use them in
    conjunction here.
  </body>
</html>
